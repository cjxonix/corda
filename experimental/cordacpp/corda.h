#ifndef CORDA_H
#define CORDA_H

#include <iostream>
#include <map>
#include <fstream>
#include <sstream>

#include <proton/codec/decoder.hpp>
#include <proton/types.hpp>

namespace net {
namespace corda {

// TODO: Map kotlin.Pair to std::pair

/**
 * We define a custom name for std::unique_ptr so that we can distinguish in the type system fields that are meant to
 * be coming from the deserialisation engine. This allows us to define overloads to adapt Proton deserialisation to
 * the generated classes, which expect to be given the decoder as a constructor input.
 *
 * @tparam T
 */
template<class T>
class ptr : public std::unique_ptr<T> {
public:
    explicit ptr(T *p) : std::unique_ptr<T>(p) {}

    ptr() : std::unique_ptr<T>() {}
};

enum SchemaDescriptor {
    UNKNOWN = -1,
    ENVELOPE = 1,
    SCHEMA = 2,
    OBJECT_DESCRIPTOR = 3,
    FIELD = 4,
    COMPOSITE_TYPE = 5,
    RESTRICTED_TYPE = 6,
    CHOICE = 7,
    REFERENCED_OBJECT = 8,
    TRANSFORM_SCHEMA = 9,
    TRANSFORM_ELEMENT = 10,
    TRANSFORM_ELEMENT_KEY = 11
};

/**
 * Parses a serialised Corda AMQP message into classes generated by the generate-serialization-libs tool.
 *
 * Can also convert the given message into a debug string dump.
 */
class Parser {
public:
    explicit Parser(const std::string &bytes) : indent_(0), bytes_(bytes) {};

    /** Returns a string containing a multi-line debug representation of the message stream. */
    std::string dump(bool resolve_descriptors = true);

    template<class T>
    std::unique_ptr<T> parse() {
        proton::codec::decoder decoder = prepare_decoder();
        std::unique_ptr<T> t = std::make_unique<T>(decoder);
        decoder >> proton::codec::finish();
        return t;
    }

    template<class T>
    inline static void read_to(proton::codec::decoder &decoder, T &out) {
        decoder >> out;
    }

    // We can't add this additional wrapping without read_to.
    template<class T>
    inline static void read_to(proton::codec::decoder &decoder, std::list<ptr<T>> &out) {
        // Unwrap the descriptor surrounding the list.
        proton::codec::start start;
        decoder >> start;
        decoder.next();
        decoder >> out;
        decoder >> proton::codec::finish();
        decoder >> proton::codec::finish();
    }

    template<class K, class V>
    inline static void read_to(proton::codec::decoder &decoder, std::map<K, V> &out) {
        // Unwrap the descriptor surrounding the list.
        proton::codec::start start;
        decoder >> start;
        decoder.next();
        decoder >> out;
        decoder >> proton::codec::finish();
        decoder >> proton::codec::finish();
    }

private:
    const std::string &bytes_;

    // Returns bytes_ but with the header truncated if valid, otherwise throws.
    std::string check_corda_amqp();

    proton::codec::decoder prepare_decoder();

    // Dumping support.
    int indent_;
    std::stringstream ss;

    void dump_process(proton::codec::decoder &decoder, const std::map<proton::symbol, std::string> &schema_mappings, bool need_indent = true, bool need_newline = true);

    void dump_scalar(proton::codec::decoder &decoder, const proton::type_id &type);

    std::string indent() { return std::string(indent_, ' '); }

    void right() { indent_ += 4; }

    void left() { indent_ -= 4; }

    SchemaDescriptor corda_schema_descriptor_id(unsigned long descriptor) {
        // Descriptor IDs start with 0xc562, this is the R3 IANA assigned enterprise number and is used to avoid
        // integer namespace conflicts.
        if ((descriptor & 0xFFFF000000000000L) != (0xc562L << 48))
            return SchemaDescriptor::UNKNOWN;
        else
            return static_cast<SchemaDescriptor>((int) descriptor & 0xFF);
    }
};

/** A quick convenience for parsing bytes to an object. */
template <class T> inline std::unique_ptr<T> parse(const std::string &bytes) { return Parser(bytes).parse<T>(); }
inline std::string dump(const std::string &bytes) { return Parser(bytes).dump(); }

/**
 * A scoped object that verifies the next object in the stream matches the given descriptor, and then sets up the
 * stream for reading by entering the composite type (which is a described list). When it goes out of scope,
 * it will pop up a frame and exit the composite type.
 */
class CompositeTypeGuard {
public:
    proton::symbol sym;
    proton::codec::start block;

    CompositeTypeGuard(proton::codec::decoder &decoder, const proton::symbol &expected, int num_fields);

    virtual ~CompositeTypeGuard();

private:
    bool pop_second = false;
    proton::codec::decoder &decoder;
};


template<class T>
proton::codec::decoder &operator>>(proton::codec::decoder &d, ptr<T> &out) {
    out = corda::ptr<T>(new T(d));
    return d;
}

template<class K, class V>
proton::codec::decoder &operator>>(proton::codec::decoder &d, std::map<K, ptr<V>> &r) {
    proton::codec::start s;
    d >> s;
    assert_type_equal(proton::MAP, s.type);
    r.clear();
    for (size_t i = 0; i < s.size / 2; ++i) {
        K k;
        ptr<V> v;
        d >> k >> v;
        r.insert(std::make_pair(k, std::move(v)));
    }
    d >> proton::codec::finish();
    return d;
}

template<class K, class V>
proton::codec::decoder &operator>>(proton::codec::decoder &d, std::map<ptr<K>, ptr<V>> &r) {
    proton::codec::start s;
    d >> s;
    assert_type_equal(proton::MAP, s.type);
    r.clear();
    for (size_t i = 0; i < s.size / 2; ++i) {
        ptr<K> k;
        ptr<V> v;
        d >> k >> v;
        r.insert(std::make_pair(std::move(k), std::move(v)));
    }
    d >> proton::codec::finish();
    return d;
}

template<class K, class V>
proton::codec::decoder &operator>>(proton::codec::decoder &d, std::map<ptr<K>, V> &r) {
    proton::codec::start s;
    d >> s;
    assert_type_equal(proton::MAP, s.type);
    r.clear();
    for (size_t i = 0; i < s.size / 2; ++i) {
        ptr<K> k;
        V v;
        d >> k >> v;
        r.insert(std::make_pair(std::move(k), v));
    }
    d >> proton::codec::finish();
    return d;
}

// Utility to make message formatting a bit less painful. Use like this: msg() << "foo" << bar
struct msg {
    std::ostringstream os;

    msg() {}

    msg(const msg &m) : os(m.str()) {}

    std::string str() const { return os.str(); }

    operator std::string() const { return str(); }

    template<class T>
    msg &operator<<(const T &t) {
        os << t;
        return *this;
    }
};

inline std::ostream &operator<<(std::ostream &o, const msg &m) { return o << m.str(); }


}
}

#endif
